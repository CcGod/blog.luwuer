<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCODE 调试 Flutter 应用</title>
    <url>/2019/11/09/VSCODE-%E8%B0%83%E8%AF%95-Flutter-%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>VSCODE 调试依赖于项目根目录下的 <code>.vscode/launch.json</code> 配置文件，我们可以通过调试侧边栏的下拉框中选择“Add Configuration”来新增一个配置，或则直接编辑 <code>.vscode/launch.json</code>。</p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><ol><li>复制以下 Flutter 调试配置写入到你的 <code>.vscode/launch.json</code></li><li>修改 <code>args</code> 参数中的 <code>--local-engine</code> 和 <code>--local-engine-src-path</code> 为你当前环境的 engine 地址</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">  <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">  <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Flutter"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"dart"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"--local-engine=android_debug_arm64"</span>, </span><br><span class="line">        <span class="string">"--local-engine-src-path=E:/flutter_tools"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="launch-json-简介"><a href="#launch-json-简介" class="headerlink" title="launch.json 简介"></a>launch.json 简介</h2><ul><li><code>name</code> 必填，配置名称，方便你在下拉框中选择</li><li><code>request</code> 必填，有 <code>launch | attach</code> 值可选<ul><li><code>launch</code> 运行程序并调试</li><li><code>attach</code> 通过其他调试协议依附已运行程序进行调试</li></ul></li><li><code>type</code> 必填，调试语言类型，比如调试 NodeJS 时填 <code>node</code></li><li><code>program</code> 调试入口（文件路径）</li><li><code>args</code> 启动调试时的参数</li><li><code>env</code> 环境变量</li><li><code>cwd</code> 执行命令目录</li><li><code>runtimeExecutable</code> 使用什么命令进行调试（<code>node | dart | py</code> 等）</li><li><code>runtimeArgs</code></li><li><code>address</code> IP 地址 , <code>request: attach</code> 时使用</li><li><code>processId</code> 进程 ID , <code>request: attach</code> 时使用</li></ul>]]></content>
      <tags>
        <tag>VSCODE</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2019/11/09/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="创建新的页面或文章"><a href="#创建新的页面或文章" class="headerlink" title="创建新的页面或文章"></a>创建新的页面或文章</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>命令原型：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt; </span><br><span class="line">    <span class="comment">#layout有三种默认布局:</span></span><br><span class="line">        <span class="comment">#page(be saved to the source) 新的页面</span></span><br><span class="line">        <span class="comment">#post(be saved to the source/_posts) 新的文章（默认）</span></span><br><span class="line">        <span class="comment">#draft(be saved to the source/_drafts) 新的草稿</span></span><br></pre></td></tr></table></figure><p></p><p>注意：</p><ul><li>Hexo 默认以标题做为文件名称，但也可以<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">修改</a>；</li><li>草稿默认不显示到页面，但也可以通过修改<strong>站点配置文件</strong>中的 <code>render_drafts</code> 的值为true来预览草稿；</li><li>发布草稿到 <code>source/_posts</code> 文件夹的命令是： <code>$ hexo publish [layout] &lt;title&gt;</code>；</li></ul><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Server</a></p><h4 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server <span class="comment">#等同于 $ hexo s</span></span><br></pre></td></tr></table></figure><p>由于我的blog基于github pages搭建，故这个命令一般用于本地调试。值得一提的是，服务的默认端口是4000，如果该命令执行遇到端口冲突错误，自定义端口的命令是这样：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server -p 2333</span><br></pre></td></tr></table></figure><p></p><blockquote><p>文档中有提到，Hexo3.0 把服务器模块独立出来，需要那么单独安装 hexo-server ：<br><code>$ npm install hexo-server --save</code></p></blockquote><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h4 id="生成静态页面文件"><a href="#生成静态页面文件" class="headerlink" title="生成静态页面文件"></a>生成静态页面文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate <span class="comment">#等同于 $ hexo g</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h4 id="提交-发布静态页面"><a href="#提交-发布静态页面" class="headerlink" title="提交/发布静态页面"></a>提交/发布静态页面</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy <span class="comment">#等同于 $ hexo d</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h4 id="清除生成的静态文件"><a href="#清除生成的静态文件" class="headerlink" title="清除生成的静态文件"></a>清除生成的静态文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>此命令一般用于删除已发布的文章（删除source下的文章文件 + clean + generate），清除缓存文件 (db.json) 和已生成的静态文件 (public文件夹)</p>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 拖拽事件执行顺序</title>
    <url>/2019/11/09/HTML%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li><code>dragstart</code> 当用户开始拖动一个元素或选中的文本时触发</li><li><code>drag</code> 当拖动元素或选中的文本时触发</li><li><code>dragenter</code> 当拖动元素或选中的文本到一个可释放目标时触发</li><li><code>dragover</code> 当元素或选中的文本被拖到一个可释放目标上时触发（每100毫秒触发一次）</li><li><code>dragleave</code> 当拖动元素或选中的文本离开一个可释放目标时触发</li><li><code>drop</code> 当元素或选中的文本在可释放目标上被释放时触发</li><li><code>dragend</code> 当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键)</li></ol><blockquote><p>事件名为<code>xx</code>则事件处理函数为<code>onxx</code>，例如<code>ondragstart</code></p></blockquote><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p>测试代码基于<a href="https://codepen.io/anon/pen/zMRyJB" target="_blank" rel="noopener">MDN文档范例</a></p></blockquote><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropzone"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"draggable"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"event.dataTransfer.setData('text/plain',null)"</span>&gt;</span></span><br><span class="line">        This div is draggable</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropzone"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropzone"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropzone"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#draggable</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dropzone</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blueviolet;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JAVASCRIPT"><a href="#JAVASCRIPT" class="headerlink" title="JAVASCRIPT"></a>JAVASCRIPT</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dragstart, drag, dragenter, dragover, dragleave, drop, dragend, dragexit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可拖动的目标元素会触发事件 */</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"drag"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!drag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'drag'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  drag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"dragstart"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragstart) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dragstart'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dragstart = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 保存拖动元素的引用(ref.)</span></span><br><span class="line">  dragged = event.target;</span><br><span class="line">  <span class="comment">// 使其半透明</span></span><br><span class="line">  event.target.style.opacity = <span class="number">.5</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"dragend"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragend) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dragend'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dragend = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 重置透明度</span></span><br><span class="line">  event.target.style.opacity = <span class="string">""</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 放下目标节点时触发事件 */</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragover) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dragover'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dragover = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 阻止默认动作</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragenter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dragenter'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dragenter = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 当可拖动的元素进入可放置的目标高亮目标节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className == <span class="string">"dropzone"</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">"purple"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"dragleave"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!dragleave) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dragleave'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dragleave = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当拖动元素离开可放置目标节点，重置其背景</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className == <span class="string">"dropzone"</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"drop"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'drop'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  drop = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 阻止默认动作（如打开一些元素的链接）</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="comment">// 移动拖动的元素到所选择的放置目标节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className == <span class="string">"dropzone"</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">""</span>;</span><br><span class="line">    dragged.parentNode.removeChild(dragged);</span><br><span class="line">    event.target.appendChild(dragged);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>dragstart<br>drag<br>dragenter<br>dragover<br>dragleave<br>drop<br>dragend</p>]]></content>
      <tags>
        <tag>html</tag>
        <tag>draggable</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用笔记</title>
    <url>/2019/11/09/Git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="设置命令别名"><a href="#设置命令别名" class="headerlink" title="设置命令别名"></a>设置命令别名</h2><ul><li><code>git config --global -e</code>进入config设置</li><li>在alias下面添加别名规则：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    st = status</span><br><span class="line">    br = branch</span><br><span class="line">    mg = merge</span><br><span class="line">    ci = commit</span><br><span class="line">    cf = config</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h2><p>如果你发现上一次提交遗漏了某个文件，或者修改未完毕就提交了，总之是想要对上一次提交内容和提交信息做修改，那么就用 <code>commit</code> 的 <code>--amend</code> 选项吧。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m <span class="string">'new commit message will cover the old one'</span></span><br></pre></td></tr></table></figure><h2 id="合并多个提交信息"><a href="#合并多个提交信息" class="headerlink" title="合并多个提交信息"></a>合并多个提交信息</h2><p>如果你在开发中习惯用 commit 保存修改信息，导致一个功能被分成多次更小粒度的提交，那么推荐在向远程仓库 push 前把提交信息合并。</p><p>这里假设你希望把最近三条提交合并一条，并修改提交信息为”commit message”:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用 -i HEAD^3 来指定最近三条提交</span></span><br><span class="line">git rebase -i HEAD^3</span><br></pre></td></tr></table></figure><p>然后你会看到如下信息：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick f7f3f6d commit message 1</span><br><span class="line">pick 310154e commit message 2</span><br><span class="line">pick a5f4a0d commit message 3</span><br></pre></td></tr></table></figure><p></p><p>修改为如下并保存：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pick f7f3f6d commit message</span><br><span class="line">squash 310154e commit message 2</span><br><span class="line">squash a5f4a0d commit message 3</span><br></pre></td></tr></table></figure><p></p>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript函数call和apply讲解</title>
    <url>/2018/10/26/Javascript%E5%87%BD%E6%95%B0call%E5%92%8Capply%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>call()/apply()</code>调用一个函数, 并指定函数的this指和参数</p><blockquote><p><code>A.fun.call(B, arg1, arg2)</code>指A对象调用B对象的fun方法，参数是<code>arg1, arg2</code></p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>call()</code>接收多个参数，<code>apply()</code>则只接受一个数组参数</p><p>故<code>A.fun.call(B, arg1, arg2)</code>与<code>A.fun.apply(B, [arg1, arg2])</code>是等效的</p><p>展开运算符(es6)出现之前的，我们就通过apply来把数组转化为函数的入参<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="number">0</span></span><br><span class="line">  values.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    temp += value</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line">add.apply(<span class="literal">null</span>, arr) <span class="comment">// 由于add()中没有访问this，故null这个参数随便填什么都可以的，后面会讲到</span></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line">add(...arr)</span><br></pre></td></tr></table></figure><p></p><h3 id="举例讲解"><a href="#举例讲解" class="headerlink" title="举例讲解"></a>举例讲解</h3><p><strong>call()/apply()只是在更改函数的调用环境（函数中的this指向）</strong></p><h5 id="例1-函数内部不访问this"><a href="#例1-函数内部不访问this" class="headerlink" title="例1 - 函数内部不访问this"></a>例1 - 函数内部不访问this</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add this指向window对象</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub this指向window对象</span></span><br><span class="line"><span class="keyword">let</span> sub = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b</span><br><span class="line"></span><br><span class="line">add.apply(sub, [<span class="number">5</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 执行add(5, 2)，并且this更改为sub()中的this（也就是window/undefined），但因为add()中没有访问this.xx，所以只是单纯执行add(5, 2)~</span></span><br><span class="line"><span class="comment">// window/undefined视是否为严格模式</span></span><br></pre></td></tr></table></figure><h5 id="例2-函数内部访问this"><a href="#例2-函数内部访问this" class="headerlink" title="例2 - 函数内部访问this"></a>例2 - 函数内部访问this</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blog1 = &#123;</span><br><span class="line">  name: <span class="string">'luwuer blog'</span>,</span><br><span class="line">  des: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// blog1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// luwuer log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> blog2 = &#123;</span><br><span class="line">  name: <span class="string">'your blog'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blog1.des.call(blog2) <span class="comment">// your blog</span></span><br><span class="line"><span class="comment">// 执行blog1.des()，并且this被更改为blog2中的this（也就是指向blog2），所以输出blog2的name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'who care'</span></span><br><span class="line">blog1.des.call(<span class="literal">null</span>) <span class="comment">// who care</span></span><br><span class="line"><span class="comment">// 执行blog1.des()，并且this被更改为window，所以输出window.name</span></span><br><span class="line"><span class="comment">// null undefined找不到this，会被默认指向window</span></span><br></pre></td></tr></table></figure><p>讲道这里，就能解释常常困扰初学者的表达式: 用<code>[].slice.call(ArrayLike)</code>把ArrayLike转变为数组（实质上是根据该ArrayLike生成一个有相同元素的新数组）。ArrayLike没有slice方法（就像上方例子的blog2），所以通过[]（数组实例，就像上方例子的blog1）调用slice并由call/apply更改this指向，最终slice方法返回ArrayLike元素组成的数组。</p><blockquote><p>slice方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括end）决定的原数组的<strong>浅拷贝</strong>，无传参则返回当前数组的浅拷贝。</p></blockquote><h5 id="例3-实现继承"><a href="#例3-实现继承" class="headerlink" title="例3 - 实现继承"></a>例3 - 实现继承</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">trademark</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wheel = <span class="number">4</span></span><br><span class="line">  <span class="keyword">this</span>.des = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`品牌： <span class="subst">$&#123;trademark&#125;</span>`</span>, <span class="string">`轮子个数： <span class="subst">$&#123;<span class="keyword">this</span>.wheel&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Geely</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.trademark = <span class="string">'吉利'</span></span><br><span class="line">  Car.call(<span class="keyword">this</span>, <span class="keyword">this</span>.trademark)</span><br><span class="line">  <span class="comment">// Geely()的this,替代Car()的this,只是指明了trademark</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上方继承等同代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Geely</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.trademark = <span class="string">'吉利'</span></span><br><span class="line">  <span class="comment">// Car()的代码</span></span><br><span class="line">  <span class="keyword">this</span>.wheel = <span class="number">4</span></span><br><span class="line">  <span class="keyword">this</span>.des = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`品牌： <span class="subst">$&#123;<span class="keyword">this</span>.trademark&#125;</span>`</span>, <span class="string">`轮子个数： <span class="subst">$&#123;<span class="keyword">this</span>.wheel&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> geely = <span class="keyword">new</span> Car(<span class="string">'吉利'</span>)</span><br><span class="line"></span><br><span class="line">geely.des() <span class="comment">// 品牌： 吉利 轮子个数： 4</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCODE常用快捷键</title>
    <url>/2017/11/14/VSCODE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl + Tab <span class="comment">## 在打开的编辑器（文件）中切换，可以显示打开了哪些文件的列表，然后用鼠标选择</span></span><br><span class="line"></span><br><span class="line">Alt + 上  / 下 <span class="comment">## 上下代码互换位置</span></span><br><span class="line"></span><br><span class="line">Ctrl + N/W <span class="comment"># 新建/删除一个编辑器（文件窗口）</span></span><br><span class="line"></span><br><span class="line">Ctrl + Shift + N/W <span class="comment"># 新建/删除一个VSCode程序</span></span><br><span class="line"></span><br><span class="line">Ctrl + F2 <span class="comment"># 全选（Sublime是Alt + F3 ， 勿混淆）</span></span><br><span class="line"></span><br><span class="line">Alt + left <span class="comment"># 选取多行</span></span><br><span class="line"></span><br><span class="line">Ctrl + 1 / 2 / 3 <span class="comment"># 切换编辑器的三个视图（默认最多三个）</span></span><br></pre></td></tr></table></figure><p>其他常用的都和Sublime差不多~~~</p>]]></content>
      <tags>
        <tag>VSCODE</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器和解释器的差别</title>
    <url>/2017/09/27/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    <content><![CDATA[<p><strong>编译器</strong>：“读懂”静态语言（如Java、C++、C），并将其源代码编译为另外一种代码（如机器码、字节码）。</p><p><strong>解释器</strong>：“读懂”动态语言（如JavaScript），直接解析源码并输出运行结果。故常说的 JavaScript 引擎，比如 Chrome 的 V8 引擎，也称作 JavaScript 解释器。</p>]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>遗忘笔记之shadowsocks</title>
    <url>/2017/09/27/%E9%81%97%E5%BF%98%E7%AC%94%E8%AE%B0%E4%B9%8Bshadowsocks/</url>
    <content><![CDATA[<h4 id="shadowsocks重启"><a href="#shadowsocks重启" class="headerlink" title="shadowsocks重启"></a>shadowsocks重启</h4><ol><li><code>ps -ef|grep shadowsocks</code> 查看进程和配置文件路径</li><li><code>kill -quit 823</code> 杀死已存在进程</li><li><code>ss-server -c /etc/shadowsocks-libev/config.json start</code>启动进程（restart重启）</li></ol><blockquote><p>shadowsocks可执行文件在<code>/usr/local/bin/ss-server</code>，如果报错<code>ss-server: command not found</code>就去这里执行第三部的命令；另很多教程在start前面加上一个-d会导致nameservers报错<code>failed to set nameservers</code>，因为加上-d shadowsocks会默认去<code>/etc/resolv.conf</code>里边取值，而不是你shadowsocks的配置文件。</p></blockquote>]]></content>
      <tags>
        <tag>遗忘笔记</tag>
        <tag>linux</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux yum 安装包默认目录</title>
    <url>/2017/09/27/Linux%20yum%20%E5%AE%89%E8%A3%85%E5%8C%85%E9%BB%98%E8%AE%A4%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote><p><strong>原文<a href="https://www.cnblogs.com/kerrycode/p/6924153.html" target="_blank" rel="noopener">链接</a></strong></p></blockquote><p>YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，避免了手动安装的麻烦(寻找资源、下载；放到指定目录安装；处理依赖关系并下载依赖关系的包进行安装)。所以用yum安装，实质上是用RPM安装，所以RPM查询信息的指令都可用。</p><p>一般来说，RPM默认安装路径如下:<br>| 目录 | 目录主要内容 |<br>| — | — |<br>| /etc | RPM包配置文件位置 |<br>| /usr/bin | RPM包可执行文件文件位置 |<br>| /usr/share/doc | RPM包本的软件使用手册与帮助文档位置 |</p><blockquote><p>一般用<code>rpm -qa|grep nginx</code>获得完整包名，再用<code>rpm -ql nginx-1.12.2-2.el7.x86_64</code>查看nginx包位置</p></blockquote>]]></content>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql8首次登录重置密码</title>
    <url>/2017/09/25/Mysql8%E9%A6%96%E6%AC%A1%E7%99%BB%E5%BD%95%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<ol><li><p>登录mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_135_188_centos <span class="built_in">log</span>]<span class="comment"># mysql -uroot -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 9</span><br><span class="line">Server version: 8.0.12</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>改密码报错: <code>Your password does not satisfy the current policy requirements</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> password <span class="keyword">for</span> root@localhost = <span class="string">'123456'</span>;</span><br><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure></li><li><p>修改密码等级 + 修改密码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password.policy=0; <span class="comment"># 0 LOW 1 MEDIUM 2 STRONG</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password.length=6;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER USER root@localhost IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure></li><li><p>查看密码验证相关（需要改了密码重新登录）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global variables like <span class="string">'%validate_password%'</span>;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password.check_user_name    | ON    |</span><br><span class="line">| validate_password.dictionary_file    |       |</span><br><span class="line">| validate_password.length             | 6     |</span><br><span class="line">| validate_password.mixed_case_count   | 1     |</span><br><span class="line">| validate_password.number_count       | 1     |</span><br><span class="line">| validate_password.policy             | LOW   |</span><br><span class="line">| validate_password.special_char_count | 1     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">7 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意是<code>validate_password.*</code>而不是以前的<code>validate_password_*</code></p></blockquote>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JS定义常量对象</title>
    <url>/2017/09/19/JS%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>ES6中新增const关键字，用于<strong>声明创建</strong>一个值得只读引用。</p><p>但其只是规定变量的标识符不能重新分配，例如声明变量是引用类型，则不可变的只是变量绑定的指针（JS不存在这个概念，指变量的值是栈中存放的内存地址，访问时会自动寻址找到堆中存放的对象），而对象的属性可以任意改变。<br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">o.b = <span class="number">2</span>    <span class="comment">// 可扩展</span></span><br><span class="line">o.c = <span class="number">4</span></span><br><span class="line"><span class="keyword">delete</span> o.c <span class="comment">// 可删除</span></span><br><span class="line">o.a = <span class="number">3</span>    <span class="comment">// 可修改</span></span><br><span class="line"></span><br><span class="line">a.push(<span class="number">5</span>) <span class="comment">// 可扩展</span></span><br><span class="line">a.pop()   <span class="comment">// 可删除</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment">// 可修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o) <span class="comment">// &#123;a: 3, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [3, 3, 5]</span></span><br></pre></td></tr></table></figure><p></p><p>所以const关键字并不能定义真正的常量对象，真正的常量对象应该是：不可扩展、不可删除、不可修改的。</p><p>要做到这些，我们需要一个函数的帮助。</p><h3 id="实现常量对象"><a href="#实现常量对象" class="headerlink" title="实现常量对象"></a>实现常量对象</h3><p><code>Object.freeze</code>方法可以冻结一个对象，冻结表示该对象不可扩展、不可删除、不可修改，并且不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法修改原对象，并返回该对象。（0 0 0）</p><blockquote><p><code>Object.isFrozen(obj)</code>返回obj是否被冻结。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(o)</span><br></pre></td></tr></table></figure><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul><li><code>Object.preventExtensions</code>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。（0 1 1）<blockquote><p><code>Object.isExtensible(obj)</code>返回obj是否可扩展。</p></blockquote></li><li><code>Object.seal</code>方法让一个对象变的不可扩展且不可删除（封闭），也就是永远不能再添加新的属性、删除已由属性。（0 0 1）<blockquote><p><code>Object.isSealed(obj)</code>返回obj是否被封闭。</p></blockquote></li></ul>]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas方法putImageData和fillRect画小方块效率问题</title>
    <url>/2017/09/19/Canvas%20context%20%E6%96%B9%E6%B3%95%20putImageData%20%E5%92%8C%20fillRect%20%E7%94%BB%E5%B0%8F%E6%96%B9%E5%9D%97%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>方法：分别用putImageData和fillRect画若干个12 x 12的小方块，比较执行耗时。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imageData = <span class="keyword">new</span> ImageData(<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">imageData.data.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  imageData.data[index] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>][index % <span class="number">4</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.time()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"> ctx.putImageData(imageData, x + i, y + i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd()</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.ctx.fillStyle = rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">155</span>)</span><br><span class="line"><span class="built_in">console</span>.time()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line"> ctx.fillRect(x + i, y + i, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd()</span><br></pre></td></tr></table></figure><ol><li><p>10次渲染结果：<strong>putImageData 效率是 fillRect 的 3.3%</strong></p><p>| putImageData / ms | fillRect / ms |<br>| ——– | —– |<br>| 1.348 | 0.032 |<br>| 0.767 | 0.019 |<br>| 0.550 | 0.028 |<br>| 0.296 | 0.020 |</p></li><li><p>1000次渲染结果：<strong>putImageData 效率是 fillRect 的 4.4%</strong></p><p>| putImageData / ms | fillRect / ms |<br>| ——– | —– |<br>| 40.8 | 1.99 |<br>| 23.7 | 0.95 |<br>| 20.0 | 0.94 |<br>| 19.8 | 0.81 |</p></li><li><p>10000次渲染结果：<strong>putImageData 效率是 fillRect 的 21%</strong></p><p>| putImageData / ms | fillRect / ms |<br>| ——– | —– |<br>| 48 | 6 |<br>| 51 | 22 |<br>| 37 | 7 |<br>| 55 | 7 |</p></li></ol><blockquote><p>100000次渲染结果： <strong>putImageData 效率是 fillRect 的 124%</strong></p></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>我们在绘制小方块时，请务必选择方法<code>fillRect</code>。</strong></p><p><code>putImageData</code>有类似重复执行渲染的优化，故在大量渲染，或需要复杂彩色色块渲染时才使用它。</p>]]></content>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript与浏览器的线程</title>
    <url>/2017/09/19/JavaScript%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MzU0NDU3NzM0Ng==&amp;mid=2247483675&amp;idx=1&amp;sn=447b8b89b20de742a0b0d0fe6cc69896&amp;chksm=fb7b4336cc0cca2077074a90945efc35289819d227146e3e03e2566eb655c57ebbf7a06cd3ca&amp;scene=0&amp;key=88007341ad887ed217d60acffb25ad5ba768c9a798cd4bc3f8e68cd319d78b27010ad7f228e66e1aea1d199a196a1f8187a4480141309bc82fb8c0d0a4b670b5677d478df3ba0a164da5583b0dd1aa42&amp;ascene=0&amp;uin=MjEzMTAwMzgyNQ%3D%3D&amp;devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.6+build(16G29" target="_blank" rel="noopener">这里</a>&amp;version=12020810&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100)，部分修改。</p></blockquote><blockquote><p>参考<a href="https://www.cnblogs.com/xuan52rock/p/4718259.html" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="JavaScript-是单线程的"><a href="#JavaScript-是单线程的" class="headerlink" title="JavaScript 是单线程的"></a>JavaScript 是单线程的</h3><p>作为浏览器脚本语言，JavaScript 主要用于处理页面中用户交互，以及操作 DOM 树、CSS 样式树（当然也包括服务器逻辑的交互处理），这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？（当然我们可以通过锁来解决上面的问题，但大大提高了复杂性）</p><blockquote><p>为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。Web Worker 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p></blockquote><h3 id="浏览器是多线程的"><a href="#浏览器是多线程的" class="headerlink" title="浏览器是多线程的"></a>浏览器是多线程的</h3><p>前端某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以浏览器是多线程的，它们一般会实现一下这几个线程：</p><ul><li><p>JavaScript 解释线程（主线程）</p></li><li><p>UI 渲染线程</p></li><li><p>[异步]HTTP 请求线程：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理</p></li><li><p>[异步]定时触发器线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案</p></li><li><p>[异步]浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到事件队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理</p></li></ul><blockquote><p>由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素的同时渲染界面，即 JavaScript 线程和 UI 线程同时运行，那么渲染线程前后获得的元素数据就可能不一致了。为了防止渲染出现不可预期的结果，浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起（页面卡顿原因），UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。</p></blockquote><blockquote><p>主线程把异步操作交给相应的独立线程处理，独立线程获得异步结果（比如触发了点击、取到了数据、到了触发时间），就会把相应的回调函数push到<strong>任务队列</strong>中供主线程执行。（关键词，event-loop）</p></blockquote>]]></content>
      <tags>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux iptables开放和屏蔽端口</title>
    <url>/2017/09/19/Linux%20iptables%E5%BC%80%E6%94%BE%E5%92%8C%E5%B1%8F%E8%94%BD%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p><a href="http://man.linuxde.net/iptables" target="_blank" rel="noopener">iptables命令语法</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ol><li><p>开放指定的端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               <span class="comment">#允许本地回环接口(即运行本机访问本机)</span></span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    <span class="comment">#允许已建立的或相关连的通行</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT         <span class="comment">#允许所有本机向外的访问</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    <span class="comment">#允许访问22端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    <span class="comment">#允许访问80端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 21 -j ACCEPT    <span class="comment">#允许ftp服务的21端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 20 -j ACCEPT    <span class="comment">#允许FTP服务的20端口</span></span><br><span class="line">iptables -A INPUT -j reject       <span class="comment">#禁止其他未允许的规则访问</span></span><br><span class="line">iptables -A FORWARD -j REJECT     <span class="comment">#禁止其他未允许的规则访问</span></span><br></pre></td></tr></table></figure></li><li><p>屏蔽IP</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 123.45.6.7 -j DROP       <span class="comment">#屏蔽单个IP的命令</span></span><br><span class="line">iptables -I INPUT -s 123.0.0.0/8 -j DROP      <span class="comment">#封整个段即从123.0.0.1到123.255.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 124.45.0.0/16 -j DROP    <span class="comment">#封IP段即从123.45.0.1到123.45.255.254的命令</span></span><br><span class="line">iptables -I INPUT -s 123.45.6.0/24 -j DROP    <span class="comment">#封IP段即从123.45.6.1到123.45.6.254的命令是</span></span><br></pre></td></tr></table></figure></li><li><p>查看已添加的iptables规则</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L -n -v</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy DROP 48106 packets, 2690K bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"> 5075  589K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"> 191K   90M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">1499K  133M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">4364K 6351M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line"> 6256  327K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination         </span><br><span class="line"> 5075  589K ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure></li><li><p>删除已添加的iptables规则<br>将所有iptables以序号标记显示，执行：<code>iptables -L -n --line-numbers</code><br>比如要删除INPUT里序号为8的规则，执行：<code>iptables -D INPUT 8</code></p></li></ol>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 常用命令</title>
    <url>/2017/09/19/MySql%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>登录Mysql： <code>mysql -u root -p</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 退出</span></span><br><span class="line">mysql&gt; exit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有数据库名</span></span><br><span class="line">mysql&gt; show databases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数据库</span></span><br><span class="line">mysql&gt; create database @database_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个数据库</span></span><br><span class="line">mysql&gt; drop database @database_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个数据库操作</span></span><br><span class="line">mysql&gt; use @database_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前数据库下所有的表名</span></span><br><span class="line">mysql&gt; show tables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个表</span></span><br><span class="line">mysql&gt; create table @table_name(uid bigint(20) not null, uname varchar(20) not null)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个表</span></span><br><span class="line">mysql&gt; drop table @table_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT @col_name FROM @table_name 检索（FROM为必须子句，以下为可选子句）</span></span><br><span class="line"><span class="comment"># DISTINCT 返回不同值。必须放在列名前边，不能部分使用DISTINCT</span></span><br><span class="line"><span class="comment"># LIMIT OFFSET 限制值位置和条数。`LIMIT 5` 限制返回五条；`LIMIT 5,5` LIMIT 5 OFFSET 5 的从第五条数据开始检索，限制五条</span></span><br><span class="line"><span class="comment"># ORDER BY 排序。1. 必须作为SELECT的最后一条子句；2. 多列排序；3. 位置排序：`SELECT name, phone FROM user ORDER BY 1, 2`等同于`...ORDER BY name, phone`；4. 默认正序，倒序DESC `ORDER BY name DESC, phone DESC`</span></span><br><span class="line">mysql&gt; SELECT phone, DISTINCT name LIMIT 2,2 FROM user ORDER BY uid DESC, 2;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat连接MySql 8报错：Client does not support authentication protocol requested by server</title>
    <url>/2017/09/19/Navicat%E8%BF%9E%E6%8E%A5Mysql%E6%8A%A5%E9%94%99%EF%BC%9AClient%20does%20not%20support%20authentication%20protocol%20requested%20by%20server/</url>
    <content><![CDATA[<p>Navicat连接新装Mysql报错： <code>Client does not support authentication protocol requested by server...</code></p><p>解决办法：</p><ul><li><p>进入安装目录/bin</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> %PATH%\bin <span class="comment"># %PATH% Mysql安装目录</span></span><br></pre></td></tr></table></figure></li><li><p>登录mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">mysql -u root -p </span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">Enter password: ************</span><br></pre></td></tr></table></figure></li><li><p>修改密码及密码加密方式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改密码及密码加密方式</span></span><br><span class="line">ALTER USER root@localhost IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>; </span><br><span class="line"><span class="comment"># 刷新MySQL的系统权限相关表</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 常用优化总结</title>
    <url>/2017/09/19/Nginx%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Nginx常用优化总结"><a href="#Nginx常用优化总结" class="headerlink" title="Nginx常用优化总结"></a>Nginx常用优化总结</h1><h2 id="基础匹配规则"><a href="#基础匹配规则" class="headerlink" title="基础匹配规则"></a>基础匹配规则</h2><p>语法：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配优先级排序</span></span><br><span class="line"></span><br><span class="line">=  <span class="comment"># 进行普通字符精确匹配</span></span><br><span class="line">^~ <span class="comment"># 表示普通字符匹配，如果该选项匹配，则不再匹配别的选项，一般用来匹配目录</span></span><br><span class="line">~  <span class="comment"># 波浪线表示执行一个正则匹配，区分大小写</span></span><br><span class="line">~* <span class="comment"># 表示执行一个正则匹配，不区分大小写</span></span><br><span class="line">@  <span class="comment"># 定义一个命名的location，使用在内部定向时，例如 error_page, try_files</span></span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location  = / &#123; </span><br><span class="line">  <span class="comment"># 只匹配"/"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /images/ 开始的请求，匹配成功则不再匹配其它location</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123; </span><br><span class="line">  <span class="comment"># 匹配任何请求，因为所有请求都是以"/"开始</span></span><br><span class="line">  <span class="comment"># 但是更长字符匹配或者正则表达式匹配会优先匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* .(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  <span class="comment"># 匹配以 gif / jpg / jpeg 结尾的请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="1-expires缓存调优"><a href="#1-expires缓存调优" class="headerlink" title="1. expires缓存调优"></a>1. expires缓存调优</h2><p>主要针对图片视频等占用带宽的文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ~* \.(jpeg|png|gif|jpg)$ &#123; <span class="comment"># 匹配任何以 .jpeg / .png / .gif / .jpg 结尾的图片</span></span><br><span class="line"></span><br><span class="line">   expires 7d; <span class="comment"># 缓存7天</span></span><br><span class="line"></span><br><span class="line">   log_not_found off; <span class="comment"># 是否在error.log中记录不存在的错误, 默认是</span></span><br><span class="line"></span><br><span class="line">   access_log off; <span class="comment"># 是否在access.log中记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-防盗链"><a href="#2-防盗链" class="headerlink" title="2. 防盗链"></a>2. 防盗链</h2><p>防止有人直接使用自己网站中的图片\视频链接，消耗服务器宽带资源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ~* ^/images/.+\.(jpg|gif|png|swf|flv|wma|wmv|asf|mp3|mmf|zip|rar)$ &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有效的请求来源: 没有来源（none）、有来源但被防火墙或代理去除了、ww..</span></span><br><span class="line">    valid_referers none blocked www.luwuer.com luwuer.com; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123; <span class="comment"># 非法的请求来源</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># rewrite www.baidu.com</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">return</span> 404;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     access_log off;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3-gzip调优"><a href="#3-gzip调优" class="headerlink" title="3. gzip调优"></a>3. gzip调优</h2><p>使用gzip压缩功能，可能为我们节约带宽，加快传输速度。</p><p>Nginx启用压缩功能需要你来ngx_http_gzip_module模块， 一般我们需要压缩的内容有：文本、js、html、css。</p><p>gzip需要消耗CPU计算资源。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">  gzip on; <span class="comment"># 开启压缩功能</span></span><br><span class="line"></span><br><span class="line">  gzip_min_length 1k; <span class="comment"># 允许压缩的（页面、文件、请求）最小字节数，小于1k或得不偿失</span></span><br><span class="line"></span><br><span class="line">  gzip_buffers 4 32k; <span class="comment"># 压缩缓冲区大小，表示申请4个单位为32K的内存作为压缩结果流缓存</span></span><br><span class="line"></span><br><span class="line">  gzip_http_version 1.1; <span class="comment"># 压缩版本，用于设置识别http版本</span></span><br><span class="line"></span><br><span class="line">  gzip_comp_level 6; <span class="comment"># 压缩比例，1压缩比例最小、消耗cpu资源也少，9最大...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 压缩请求类型，默认text/html</span></span><br><span class="line">  gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line"></span><br><span class="line">  gzip_vary on; <span class="comment"># vary header支持，让浏览器可以缓存经过gzip压缩的页面</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 作为反向代理服务器时启用，决定是否对代理请求的应答启用gzip，any表示无条件进行压缩，其他选项不做列举</span></span><br><span class="line">  gzip_proxied any; </span><br><span class="line"></span><br><span class="line">  <span class="comment"># server &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启高效传输模式"><a href="#开启高效传输模式" class="headerlink" title="开启高效传输模式"></a>开启高效传输模式</h2><blockquote><p>如果图片显示不正常，把sendfile修改为off</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span></span><br><span class="line">  sendfile on; </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 必须在sendfile开启模式才有效，防止网路阻塞，积极的减少网络报文段的数量（告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送）</span></span><br><span class="line">  tcp_nopush on;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># server &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接超时时间"><a href="#连接超时时间" class="headerlink" title="连接超时时间"></a>连接超时时间</h2><p>主要目的是保护服务器资源，CPU，内存，控制连接数，因为建立连接也是需要消耗资源的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keepalive_timeout 60; <span class="comment"># 客户端连接保持会话超时时间，超过这个时间，服务器断开这个链接</span></span><br></pre></td></tr></table></figure><blockquote><p>更多参见<a href="https://blog.csdn.net/Kangshuo2471781030/article/details/79198716" target="_blank" rel="noopener">这里</a></p></blockquote>]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli-3.0笔记</title>
    <url>/2017/09/19/vue-cli-3.0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><p>CLI 插件：每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。附： <a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">插件开发指南</a></p></li><li><p>abc</p></li></ul><h3 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h3><ol><li><p><code>yarn global add @vue/cli</code> 安装vue/cli</p></li><li><p><code>vue create hello-world</code> 创建hello-world项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  -p, --preset &lt;presetName&gt;       忽略提示符并使用已保存的或远程的预设选项</span><br><span class="line">  -d, --default                   忽略提示符并使用默认预设选项</span><br><span class="line">  -i, --inlinePreset &lt;json&gt;       忽略提示符并使用内联的 JSON 字符串预设选项</span><br><span class="line">  -m, --packageManager &lt;<span class="built_in">command</span>&gt;  在安装依赖时使用指定的 npm 客户端</span><br><span class="line">  -r, --registry &lt;url&gt;            在安装依赖时使用指定的 npm registry (仅用于 npm 客户端)</span><br><span class="line">  -g, --git [message]             强制 / 跳过 git 初始化，并可选的指定初始化提交信息</span><br><span class="line">  -f, --force                     覆写目标目录可能存在的配置</span><br><span class="line">  -c, --<span class="built_in">clone</span>                     使用 git <span class="built_in">clone</span> 获取远程预设选项</span><br><span class="line">  -x, --proxy                     使用指定的代理创建项目</span><br><span class="line">  -h, --<span class="built_in">help</span>                      输出使用帮助信息</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li><li><p><code>vue ui</code> 打开图形化界面创建和管理项目</p></li><li><p><code>vue add @vue/eslint</code> 为已创建项目安装插件,这个命令将 @vue/eslint 解析为完整的包名 @vue/cli-plugin-eslint，然后从 npm 安装它，调用它的生成器。</p><blockquote><p>vue add 的设计意图是为了安装和调用 Vue CLI 插件。这不意味着替换掉普通的 npm 包。对于这些普通的 npm 包，你仍然需要选用包管理器。</p></blockquote><blockquote><p>我们推荐在运行 vue add 之前将项目的最新状态提交，因为该命令可能调用插件的文件生成器并很有可能更改你现有的文件。</p></blockquote></li></ol>]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCODE终端集成git</title>
    <url>/2017/08/09/VSCODE%E7%BB%88%E7%AB%AF%E9%9B%86%E6%88%90git/</url>
    <content><![CDATA[<blockquote><p>安装git不再赘述…</p></blockquote><h3 id="VSCODE终端集成git"><a href="#VSCODE终端集成git" class="headerlink" title="VSCODE终端集成git"></a>VSCODE终端集成git</h3><ul><li><code>VSCODE/首选项/设置</code>或<code>ctrl+shift+P -&gt; 输入:user setting</code>打开用户设置</li><li><p>在右侧（用户设置）添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 终端在 Windows 上使用的 shell 的路径。</span><br><span class="line">&quot;terminal.integrated.shell.windows&quot;: &quot;[git_path]//bin//bash.exe&quot;</span><br></pre></td></tr></table></figure></li><li><p>把[git_path]修改为git安装目录，比如：<code>E://apps//Git//bin//bash.exe</code></p></li></ul>]]></content>
      <tags>
        <tag>git</tag>
        <tag>VSCODE</tag>
      </tags>
  </entry>
  <entry>
    <title>更换电脑后继续更新修改Hexo Blog</title>
    <url>/2017/08/09/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E7%BB%A7%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%BF%AE%E6%94%B9Hexo-Blog/</url>
    <content><![CDATA[<p>通过Hexo搭建好Blog后,常常因为一些必须原因，需要在别的电脑更新Blog…</p><h3 id="更换电脑前的操作"><a href="#更换电脑前的操作" class="headerlink" title="更换电脑前的操作"></a>更换电脑前的操作</h3><blockquote><p>核心工作就是，备份你搭建blog后的本地环境… 我这里选择把原项目全部push到<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:xx/xx.github.io/`的分支上</p></blockquote><ul><li><code>git init</code>你的本地hexo blog项目，这里解释下<code>hexo d</code>只是把项目生成的静态页面发布到github~</li><li><code>git remote add origin git@github.com:xx/xx.github.io</code>关联本地仓库和远程仓库</li><li>重命名项目目录下的<code>.gitignore</code>文件，随便在后面加个下划线什么的，让他的功能（告诉git忽略一些文件或目录）不生效</li><li><code>git checkout -b branch</code> 新建branch分支，并切换到分支</li><li><p>打包<code>./themes/</code>目录下的主题，我用的是hexo-theme-next，故压缩这个包</p><blockquote><p>为什么要打包这个主题而不是在新环境中重新git clone一个新的主题呢： 主题下的.gitignore文件修改不起作用（我自己），故只有在新环境中重新git clone你用的主题的开源项目。而又因本地项目的主题中，可能存在着很多你对样式和配置的修改，新clone的主题当然什么也没有！我踩过坑，故提一下…</p></blockquote></li><li><p><code>git add .</code> + <code>git commit -m &#39;xxx&#39;</code></p></li><li><code>git push -u origin branch</code>本地仓库内容推送到分支</li></ul><p><strong>OK！ 现在你可以在另一台电脑上git clone…</strong></p><h3 id="更换电脑后的操作"><a href="#更换电脑后的操作" class="headerlink" title="更换电脑后的操作"></a>更换电脑后的操作</h3><blockquote><p>好累，不写注释了</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xx/xx.github.io</span><br><span class="line">git checkout branch</span><br><span class="line"><span class="built_in">cd</span> xx.github.io</span><br><span class="line">npm install hexo</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br><span class="line"><span class="comment">## 然后解压你的主题，解压到压缩包在的路径</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment">## 回到项目根目录</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"><span class="comment">## 等等... 应该都没问题了</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git同步本地项目到GitHub</title>
    <url>/2017/08/08/Git%E5%90%8C%E6%AD%A5%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0github/</url>
    <content><![CDATA[<p>相信很多朋友都曾遇到过这样一个问题，想要在另一台电脑上同步你的个人项目，以便能身居‘异地’也依然能同步开发！所以我们把自己的项目同步到远程仓库，想在哪里里开发，就pull到本地改完再push到远程仓库，极其方便~</p><p>鉴于有好几次都记错了相关命令，故记于此，来日多多翻阅…</p><blockquote><p>安装git和如何使用github不做讲诉…</p></blockquote><h3 id="准备工作，本地git获得github的提交权限"><a href="#准备工作，本地git获得github的提交权限" class="headerlink" title="准备工作，本地git获得github的提交权限"></a>准备工作，本地git获得github的提交权限</h3><ul><li>设置用户名和邮箱<ul><li><code>git config --global user.name {yourName}</code></li><li><code>git config --global user.email {yourEmail}</code></li></ul></li><li>生成SSH密匙 <code>ssh-keygen -t rsa -C {yourEmail}</code>,email和你设置的git邮箱一致<blockquote><p>指令执行后会让你确定密钥保存地址和设置密码，这些不用管，全部回车就好</p></blockquote></li><li>添加生成的id_rsa.pub文件中的公钥（打开复制）到github的<strong>Setting / Deploy keys</strong></li><li>最后测试是否关联成功,git bash输入<code>ssh git@github.com</code>, 如果提示”successfully authenticated”则成功</li></ul><h3 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h3><ul><li>cd到项目目录</li><li><code>git init</code> 初始化git仓库</li><li><code>git add .</code> 把所有项目文件添加到提交暂存区</li><li><code>git commit -m &#39;提交说明&#39;</code> 把暂存区中的内容提交到仓库</li></ul><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><blockquote><p>本文使用github，创建仓库步骤不赘述，仓库名（也就是项目名）<code>{resName}</code></p></blockquote><h3 id="同步本地仓库到远程仓库"><a href="#同步本地仓库到远程仓库" class="headerlink" title="同步本地仓库到远程仓库"></a>同步本地仓库到远程仓库</h3><ul><li><code>git remote add origin git@github.com:{githubUerName}/{resName}</code> 关联本地仓库和远程仓库</li><li><code>git push -u origin master</code> 把本地仓库内容push到远程仓库的master分支<blockquote><p><code>push</code>的<code>-u</code>参数是设置本地仓库默认的<code>upstream</code>,这里就是把本地仓库同远程仓库的master分支进行关联，之后你在这个仓库pull时不带参数也默认从master分支拉取</p></blockquote></li></ul><h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h3><p><strong>1.<code>push</code>时报错不能覆盖远程仓库代码</strong></p><p>新建远程仓库，你或许会不注意自动生成了README.md。不需要，故直接强制覆盖<code>-f</code>。<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -uf origin master</span><br></pre></td></tr></table></figure><p></p><p><strong>1.<code>git remote add origin git@github.com:{githubUerName}/{resName}</code>时报错<code>remote origin already exists</code>origin别名已经存在</strong></p><p>删除origin，然后重试。<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p></p>]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
